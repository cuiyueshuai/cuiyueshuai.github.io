<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React Native可伸缩列表封装与快速实现方案]]></title>
    <url>%2F2017%2F07%2F04%2FReact%20Native%2FReact%20Native%E5%8F%AF%E4%BC%B8%E5%B1%95%E5%88%97%E8%A1%A8%E5%B0%81%E8%A3%85%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[React Native可伸缩列表封装与快速实现方案 类似QQ好友列表的可伸缩分组列表，相信对于一部分的开发者来说还是有需要用到的，笔者将会结合自己的开发理解和已发布在github和npm上的实例，结合讲解如何使用React Native快速封装此类组件。你也可以查看笔者已经封装并发布的组件react-native-expandable-section-list查看效果，当然在你的项目中，你也可以直接使用该组件，如发现任何bug请及时提出issue给我，我会认真处理，如果你觉得笔者做的还不错，请给我一个star哦！ ##封装思路解析原生ios开发阶段时，UITableView功能强大，实现类似QQ列表这样的功能，你只需要在UITableView的delegate方法中作相关控制即可实现，但是最开始转到react native的时候，笔者由于当时刚参加工作，没什么思路，后经过一些尝试和封装，笔者有了现在的实现方法 思路一： 通过View的onLayout回调记录分组布局大小，控制打开组高度和关闭组高度实现类似开关分组效果（这个思路和代码是一个同事的方法，代码稍微有点绕，但是可以控制打开关闭的动画，笔者暂时放弃了，但是笔者下一篇文章会来讲解这个方法的思路和实现） 思路二： 控制数据，改变开关分组的标记值，并结合react native的state渲染实现类似开关分组效果（这是笔者当前用在实际项目中的一个组件，下面会具体介绍如何实现它的代码和思路） ##代码解析首先渲染一个全屏的ListView，ListView中的row当作分组，row渲染成下列组件： 分组渲染： 123456789101112131415161718192021222324252627_renderRow = (rowData, sectionId, rowId) =&gt; &#123; // eslint-disable-line const &#123; renderRow, renderSectionHeaderX, renderSectionFooterX, headerKey, memberKey &#125; = this.props; let memberArr = rowData[memberKey]; if (!this.state.memberOpened.get(rowId) || !memberArr) &#123; memberArr = []; &#125; return ( &lt;View&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; this._onPress(rowId)&#125;&gt; &#123; renderSectionHeaderX ? renderSectionHeaderX(rowData[headerKey], rowId) : null&#125; &lt;/TouchableOpacity&gt; &lt;ScrollView scrollEnabled=&#123;false&#125;&gt; &#123; memberArr.map((rowItem, index) =&gt; &#123; return ( &lt;View key=&#123;index&#125;&gt; &#123;renderRow ? renderRow(rowItem, index, sectionId) : null&#125; &lt;/View&gt; ); &#125;) &#125; &#123; memberArr.length &gt; 0 &amp;&amp; renderSectionFooterX ? renderSectionFooterX(rowData, sectionId) : null &#125; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125; 说明：如代码，每个Row中都由renderSectionHeaderX、renderRow、renderSectionFooterX组成，renderSectionHeaderX通过Touchable组件的点击事件，可以控制下面的ScrollView包着的一个个组成员renderRow，及sectionFooter，每次渲染这样一个分组的时候通过当前组的开关状态this.state.memberOpened来获得当前memberArr数组是空数组或是你的传入数据rowData[memberKey],当然也可以控制你的关闭状态不一定是空数组，这里的开关状态寄存器是一个Map对象，或者你也可以自己构造合适的键值对对象 开关对象构造： 123456789101112131415constructor(props) &#123; super(props); this.ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;); let map = new Map(); if (props.dataSource &amp;&amp; props.isOpen) &#123; props.dataSource.map((item, i) =&gt; map.set(i.toString(), true)) &#125; if (props.openOptions) &#123; props.openOptions.map((item) =&gt; map.set(item.toString(), true)) &#125; this.state = &#123; memberOpened: map &#125; &#125; 说明：构造状态寄存器，通过属性设置默认的分组开关状态，isOpen是bool值，记录是否全部打开分组, openOptions是一个数组，里面记录你选择打开哪些分组，如打开0, 2分组，即为[0,2] 点击开关方法： 12345678910111213_onPress = (i) =&gt; &#123; this.setState((state) =&gt; &#123; const memberOpened = new Map(state.memberOpened); memberOpened.set(i, !memberOpened.get(i)); // toggle return &#123; memberOpened &#125;; &#125;); if (this.props.headerOnPress) &#123; this.prop.headerOnPress(i, this.state.memberOpened.get(i) || false); &#125; LayoutAnimation.easeInEaseOut(); &#125;; 说明：每次点击组头，执行该方法，改变当前组在状态寄存器中设置的状态，最开始笔者甚至把这状态寄存设置成为每个分组数据的某个特定属性，后来发现Map拿来这里当作一种寄存器用真的很完美。 数据源 123456789101112131415const MockData = [ ... &#123; header: &apos;sectionHeader&apos;, member: [ ... &#123; title: &apos;memberTitle&apos;, content: &apos;content&apos;, &#125;, ... ] &#125;, ... ] 特定组件是拿来做特定用途的，所以笔者做的react-native-expandable-section-list只适用于笔者说明的情况，当然，也对数据源做一定的限制，从而快速封装出来QQ列表的可伸缩分组效果。 ##FlatList扩展封装react native在版本0.43后提出使用FlatList，笔者在使用FlatList的时候，通过同样的思路也对FlatList做了类似的扩展，组件可见react-native-expandable-section-flatlist，0.43版本后的FlatList确实是对列表组件性能做了极大的提升，数据源data属性，加上扩展数据属性extraData的使用让每次的state组件渲染不会再是渲染当前列表，而是直接定位到你作出改变的分组从而改变分组的开关状态。keyExtractor属性也更加利于定位每一个分组的位置和设定，笔者在数据测试时只做了100个分组的测试，FlatList的性能原理是只会显示你看到的这部分分组，做的还是相当好的，暂未发现性能影响。笔者尽量减少对原组件FlatList的属性影响，其他类似上拉刷新，下拉加载等属性也全部兼容，接下来直接展示精简后的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class ExpanableList extends Component &#123; constructor(props) &#123; super(props); let map = new Map(); if (props.dataSource &amp;&amp; props.isOpen) &#123; props.dataSource.map((item, i) =&gt; map.set(i, true)) &#125; if (props.openOptions) &#123; props.openOptions.map((item) =&gt; map.set(item, true)) &#125; this.state = &#123; memberOpened: map &#125; &#125; static propTypes = &#123; dataSource: PropTypes.array.isRequired, headerKey: PropTypes.string, memberKey: PropTypes.string, renderRow: PropTypes.func, renderSectionHeaderX: PropTypes.func, renderSectionFooterX: PropTypes.func, headerOnPress: PropTypes.func, isOpen: PropTypes.bool, openOptions: PropTypes.array, &#125;; static defaultProps = &#123; headerKey: 'header', memberKey: 'member', isOpen: false, &#125;; _keyExtractor = (item, index) =&gt; index; _onPress = (i) =&gt; &#123; this.setState((state) =&gt; &#123; const memberOpened = new Map(state.memberOpened); memberOpened.set(i, !memberOpened.get(i)); // toggle return &#123; memberOpened &#125;; &#125;); if (this.props.headerOnPress) &#123; this.prop.headerOnPress(i, this.state.memberOpened.get(i) || false); &#125; LayoutAnimation.easeInEaseOut(); &#125;; _renderItem = (&#123; item, index &#125;) =&gt; &#123; // eslint-disable-line const &#123; renderRow, renderSectionHeaderX, renderSectionFooterX, headerKey, memberKey &#125; = this.props; const sectionId = index; let memberArr = item[memberKey]; if (!this.state.memberOpened.get(sectionId) || !memberArr) &#123; memberArr = []; &#125; return ( &lt;View&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; this._onPress(sectionId)&#125;&gt; &#123; renderSectionHeaderX ? renderSectionHeaderX(item[headerKey], sectionId) : null&#125; &lt;/TouchableOpacity&gt; &lt;ScrollView scrollEnabled=&#123;false&#125;&gt; &#123; memberArr.map((rowItem, rowId) =&gt; &#123; return ( &lt;View key=&#123;rowId&#125;&gt; &#123;renderRow ? renderRow(rowItem, rowId, index) : null&#125; &lt;/View&gt; ); &#125;) &#125; &#123; memberArr.length &gt; 0 &amp;&amp; renderSectionFooterX ? renderSectionFooterX(item, sectionId) : null &#125; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125;; render() &#123; const &#123; dataSource &#125; = this.props; return ( &lt;FlatList &#123;...this.props&#125; data=&#123;dataSource&#125; extraData=&#123;this.state&#125; keyExtractor=&#123;this._keyExtractor&#125; renderItem=&#123;this._renderItem&#125; /&gt; ); &#125;&#125; ##写在最后react-native-expandable-section-list和react-native-expandable-section-flatlist封装的相对简单，但是还是很实用的，笔者的一点小经验分享希望能对你有所帮助。 写总结和分享文章确实是一件快乐的事情，笔者的第一篇文章React Native路由理解和react-navigation库封装学习受到了一些人的肯定，真的很开心，谢谢各位，一起进步！！]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native路由理解和react-navigation库封装学习]]></title>
    <url>%2F2017%2F06%2F20%2FReact%20Native%2FReact%20Native%E8%B7%AF%E7%94%B1%E7%90%86%E8%A7%A3%E5%92%8Creact-navigation%E5%BA%93%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[React Native路由理解和react-navigation库封装学习从0.44版本开始Facebook放弃了原来的Navigator接口控制RN应用的路由跳转，并推荐使用react-navigation库实现应用的导航和跳转等功能。本文不止会介绍react-navigation的学习和使用，并同时也会介绍曾经的Navigator接口使用并介绍它们如何在应用中实现路由跳转的集中管理。笔者不会过多的介绍Navigator和react-navigation各个属性和方法的使用，笔者旨在学习和理解在react native中的栈结构路由的使用。 栈概念理解对于手机应用中单页面应用（SPA）的路由，你可以这样理解： 应用（APP）== 整套扑克牌（包括牌盒） 栈容器（Navigator或React-Navigation中的 StackNavigator）== 牌盒 页面（路由） == 牌 现在我们往空牌盒里面放入牌J，这是你的初始化页面，你可以再放入一张牌Q，盖住了牌J，在你的应用中你看到的页面就变成了牌Q，这个操作就是PUSH，然后你又把牌Q从牌盒中拿出来，你可以返回到之前的牌J，这个操作就是POP，通常PUSH操作你只能按顺序一次次的放入一个个对象，这个对象也许是一张牌，但是也有可能是封装多个同级页面的容器，比如说你的Tab容器页面；这就是单页面最简单的跳转和返回路由操作，其他还有以下相关操作： reset（重置）： 在已经有牌J、Q、K的牌盒里面，把所有的牌全部一次性拿出，放入牌A，这个过程就是重置你的整个路由； popTo（返回指定页面）： 对已经有牌J、Q、K的牌盒里面对各牌进行按顺序下标0，1，2，其实就是数组结构，当前情况下你可以看到牌K，你的pop()返回至Q其实相当于popTo（1），你还可以使用popTo（0），这样你就等于一次性移开了最上面的牌Q、K，而你的牌盒中只剩下了J，这样相当于一次性按顺序返回多个页面； getCurrentRoutes（获取当前所有路由）： 对已经有牌J、Q、K的牌盒里面对各牌进行按顺序下标0，1，2，你可以获取到这个牌盒概念的路由数组，你可以对当前里面的牌进行指定操作。 延伸： 你的App即是你的牌盒，你只能对你牌盒中已经有的牌进行操作，当然你也可以新拿一张牌放入牌盒中进行操作，但是如果你的牌本身不在你的牌盒中，你是无法进行操作的，所以有时候如果这个牌都不在你的牌盒中，你使用通知-观察等这样的概念去操作一个不存在的页面对象是不会成功的。 Navigator使用和封装点击查看官方文档 0.44版本后Navigator已经从react-native库中移除，如需导入可按如下操作: 12345// install$npm install React-native-deprecated-custom-components --save// import APIimport CustomerComponents, &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos;; 实际项目中对于单页面应用，我们可以把Navigator封装成一个组件，把各页面当作Navigator的一个个场景转换，在页面中实现跳转，返回，动画等的各种操作时只需要调用相应方法即可。 123456789101112131415161718192021222324252627282930313233343536373839class APP extends Component &#123; constructor(props) &#123; super(props); this._renderScene = this._renderScene.bind(this); this.state = &#123;&#125;; &#125; /* eslint-disable */ _renderScene(route, navigator) &#123; let Component = route.component; return ( &lt;Component &#123;...route&#125; navigator=&#123;navigator&#125; passProps=&#123;route.passProps&#125; callback=&#123;route.callback&#125; /&gt; ); &#125; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &lt;Navigator ref="navigator" renderScene=&#123;this._renderScene&#125; configureScene=&#123;(route) =&gt; (&#123; ...route.sceneConfig || Navigator.SceneConfigs.HorizontalSwipeJump, gestures: route.gestures &#125;)&#125; initialRoute=&#123;&#123; component: Login &#125;&#125; /&gt; &lt;LoadingView isVisible=&#123;this.props.showLoading&#125; /&gt; &lt;/View&gt; ) &#125;&#125; 除了场景转换等操作，还可以在这个组件中集成控制App全局的一些操作，比如说，Loading的设置，网络状态检查等设置，在各页面就无须再单独设置。尽量在一个地方里面实现控制app的一些相近的默认操作 实际页面中跳转或其他操作： 123456789101112131415_jumpPage() &#123; const &#123; navigator &#125; = this.props; if (navigator) &#123; navigator.push(&#123; component: TabBarList, //next route sceneConfig: Navigator.SceneConfigs.FloatFromBottomAndroid, // animated config callback: () =&gt; &#123;&#125; //callback passProps: &#123; //transfer parameters tabs: 'home', activeTab: 'home', onPressHandler: this.props.goToPage &#125; &#125;); &#125; &#125; React Navigation理解和使用点击查看官方文档 react-native 0.44版本之前路由控制使用的Navigator虽然非常稳定，基本没出现过什么BUG，但是跳转效果一直被人诟病，跳转时候的动画和原生App的效果相比，非常明显差一等，在0.44版本后Facebook推荐使用react-navigation库来实现页面跳转，tab转换，侧边栏滑动等功能。 react-navigation主要包括导航，底部tab，顶部tab，侧滑等，功能很强大，而且体验接近原生。接下来会一一介绍： 导航 -&gt; StackNavigator 底部或者顶部tab -&gt; TabNavigator 关于侧滑DrawerNavigator的使用，笔者不在本文介绍，但可以看这篇附带Demo的推荐博客 ####StackNavigator StackNavigator在功能上就是相当于原来使用Navigator，但是他有着不一样的实现和非常好的跳转体验，使用上也非常简单，其实也就是三部曲： 路由配置（页面注册）： 12345const routeConfigs = &#123; Login: &#123; screen: Login &#125;, TabBar: &#123; screen: TabBarContainer &#125;, Feedback: &#123; screen: Feedback &#125;,&#125;; 默认场景配置： 123456789101112131415161718192021const stackNavigatorConfig = &#123; initialRouteName: 'Login', navigationOptions: &#123; headerBackTitle: null, headerTintColor: 'white', showIcon: true, swipeEnabled: false, animationEnabled: false, headerStyle: &#123; backgroundColor: '#f2f2f2' &#125; &#125;, mode: 'card', paths: 'rax/: Login', headerMode: 'float', transitionConfig: (() =&gt; (&#123; screenInterpolator: CardStackStyleInterpolator.forHorizontal // android's config about jump to next page &#125;)), onTransitionStart: () =&gt; &#123;&#125;, onTransitionEnd: () =&gt; &#123;&#125;&#125;; 容器生成与初始化: 12345678const Nav = StackNavigator(routeConfigs, stackNavigatorConfig);export default class QQDrawerHome extends Component &#123; render() &#123; return( &lt;Nav/&gt; ); &#125;&#125; 这样就简单完成了路由的配置，开发时只需要把新页面添加到注册对象routeConfigs中，StackNavigator会对里面的的注册页面和注册时使用的KEY值形成对应关系，当你在页面时跳转时，只需要这样： 1234567_jumpPage() &#123; const &#123; navigation &#125; = this.props; if (navigation) &#123; const &#123; navigation &#125; = this.props; navigation.navigate('TabBar'); &#125;&#125; 带参数跳转时： 12345678910_jumpPage() &#123; const &#123; navigation &#125; = this.props; if (navigation) &#123; const &#123; navigation &#125; = this.props; navigation.navigate('TabBar', &#123; visible: false, title: '首页' &#125;); &#125;&#125; 在下个页面就可以拿到参数并设置头部或其他参数： 1234567static navigationOptions = (&#123; navigation &#125;) =&gt; &#123; const &#123; state &#125; = navigation; const &#123; title &#125; = state.params; return &#123; title: title, &#125;; &#125;; 其他reset，setParams等操作将可以学着本文后面封装到组件中去使用，当然你也可以直接在页面跳转函数中重置路由，就像这样： 1234567const resetAction = NavigationActions.reset(&#123; index: 0, actions: [ NavigationActions.navigate(&#123; routeName: 'Login'&#125;) ]&#125;)this.props.navigation.dispatch(resetAction) ####TabNavigator0.44版本之前我们实现Tab页面通常都选择使用框架react-native-tab-navigator或者react-native-scrollable-tab-view，现在0.44版本后react-navigation库中推荐使用TabNavigator，同样的使用方式，类似StackNavigator三部曲： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const routeConfigs = &#123; Message:&#123; screen:QQMessage, navigationOptions: &#123; tabBarLabel: '消息', tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./notif-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt;), &#125; &#125;, Contact:&#123; screen:QQContact, navigationOptions: &#123; tabBarLabel: '联系人', tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./notif-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt;), &#125; &#125;,&#125;;const tabNavigatorConfig = &#123; tabBarComponent:TabBarBottom, tabBarPosition:'bottom', swipeEnabled:false, animationEnabled:false, lazy:true, initialRouteName:'Message', backBehavior:'none', tabBarOptions:&#123; activeTintColor:'rgb(78,187,251)', activeBackgroundColor:'white', inactiveTintColor:'rgb(127,131,146)', inactiveBackgroundColor:'white', labelStyle:&#123; fontSize:12 &#125; &#125; &#125; export default TabNavigator(routeConfigs, tabNavigatorConfig); 关于使用TabNavigator的一些注意点和当前问题： 如你甚至未使用StackNavigator，而想直接使用TabNavigator，还是用其他第三方框架吧，他和StackNavigator是配套使用的，你必须保证TabNavigator存在于StackNavigator中，TabNavigator才能良好工作。 当你当前页面使用了TabNavigator，那么TabNavigator所形成的容器组件应该是当前页面的顶层组件，否则报错，获取router为underfined。 关于嵌套使用TabNavigator，即在TabNavigator的一个screen中再次使用了TabNavigator形成页面，安卓平台下无法渲染子组件，页面空白，且内层Tab基本失效，或者你的内层Tab容器使用其他第三方框架如react-native-tab-view等类似框架，问题依然存在，关于此问题可关注公关BUG#1796。 ####StackNavigator路由的集中封装 此部分集成了一部分Redux知识，建议可以看一下redux官方文档了解一下redux。StackNavigator本身就集成了Redux来进行路由数据的管理，如你想要将你自己的redux管理集成到StackNavigator中，官方同样提供接口addNavigationHelpers，这里我们关注的是如何把reset，setParams等Navigator中的Action直接封装到组件中形成页面调用接口。 以下是笔者的封装组件，类似之前封装Navigator组件封装集中管理组件的思路代码，我们把StackNavigator同样封装为一个组件作为管理中心 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106......const AppNavigator = StackNavigator(RouteConfigs, stackNavigatorConfig);// eslint-disable-lineclass MainContainer extends Component &#123; constructor(props) &#123; super(props); this.resetRouteTo = this.resetRouteTo.bind(this); this.resetActiveRouteTo = this.resetActiveRouteTo.bind(this); this.backTo = this.backTo.bind(this); this.setParamsWrapper = this.setParamsWrapper.bind(this); this.state = &#123;&#125;; &#125; resetRouteTo(route, params) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; dispatch( NavigationActions.reset(&#123; index: 0, actions: [NavigationActions.navigate(&#123; routeName: route, params: params &#125;)], &#125;) ); &#125; &#125; resetActiveRouteTo(routeArray, activeIndex) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; const actionsArray = []; for (let i = 0; i &lt; routeArray.length; i++) &#123; actionsArray.push(NavigationActions.navigate(&#123; routeName: routeArray[i] &#125;)); &#125; const resetAction = NavigationActions.reset(&#123; index: activeIndex, actions: actionsArray, &#125;); dispatch(resetAction); &#125; &#125; backTo(key) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; dispatch( NavigationActions.reset(&#123; key: key &#125;) ); &#125; &#125; setParamsWrapper(params, key) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; const setParamsAction = NavigationActions.setParams(&#123; params: params, key: key, &#125;); dispatch(setParamsAction); &#125; &#125; render() &#123; const &#123; dispatch, navigationState, screenProps &#125; = this.props; return ( &lt;View style=&#123;&#123; flex: 1 &#125;&#125; onStartShouldSetResponder=&#123;() =&gt; dismissKeyboard()&#125; &gt; &lt;StatusBar barStyle="light-content" /&gt; &lt;AppNavigator navigation=&#123;addNavigationHelpers(&#123; dispatch: dispatch, state: navigationState, resetRouteTo: (route, params) =&gt; this.resetRouteTo(route, params), resetActiveRouteTo: (routeArray, activeIndex) =&gt; this.resetActiveRouteTo(routeArray, activeIndex), backTo: (key) =&gt; this.backTo(key), setParamsWrapper: (params, key) =&gt; this.setParamsWrapper(params, key) &#125;)&#125; screenProps=&#123;screenProps&#125; /&gt; &lt;Loading isVisible=&#123;true&#125; mode="alipay" /&gt; &lt;/View&gt; ); &#125;&#125;const mapStateToProps = (state) =&gt; &#123; const newNavigationState = state.navReducer; if (state.screenProps) &#123; newNavigationState.params = &#123; ...state.params, ...state.screenProps &#125;; &#125; return &#123; navigationState: newNavigationState, screenProps: state.screenProps &#125;;&#125;;export default connect(mapStateToProps)(MainContainer);...... 其中绑定navReducer文件的数据，可参考redux和react-navigation官网文档，此文不再列出 这样封装后，各页面使用reset，setParams等操作时，就可以像以前一样直接使用相关操作，如重置路由： 123456_jumpPage() &#123; const &#123; navigation &#125; = this.props; if (navigation) &#123; navigation.resetRouteTo('TabBar', &#123; title: '首页', selectedTab: 'home' &#125;); &#125;&#125; 写在最后笔者第一次写博客，如果有什么不足之处，或者上面的一些问题有什么不对的，欢迎大家批评与指正，一起学习和进步。 相关文章可参考： ReactNative导航新宠儿react-navigation React Native未来导航者：react-navigation 使用详解]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
</search>