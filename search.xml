<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React Native路由理解和react-navigation库封装学习]]></title>
    <url>%2F2017%2F06%2F20%2FReact%20Native%2FReact%20Native%E8%B7%AF%E7%94%B1%E7%90%86%E8%A7%A3%E5%92%8Creact-navigation%E5%BA%93%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[React Native路由理解和react-navigation库封装学习从0.44版本开始Facebook放弃了原来的Navigator接口控制RN应用的路由跳转，并推荐使用react-navigation库实现应用的导航和跳转等功能。本文不止会介绍react-navigation的学习和使用，并同时也会介绍曾经的Navigator接口使用并介绍它们如何在应用中实现路由跳转的集中管理。笔者不会过多的介绍Navigator和react-navigation各个属性和方法的使用，笔者旨在学习和理解在react native中的栈结构路由的使用。 栈概念理解对于手机应用中单页面应用（SPA）的路由，你可以这样理解： 应用（APP）== 整套扑克牌（包括牌盒） 栈容器（Navigator或React-Navigation中的 StackNavigator）== 牌盒 页面（路由） == 牌 现在我们往空牌盒里面放入牌J，这是你的初始化页面，你可以再放入一张牌Q，盖住了牌J，在你的应用中你看到的页面就变成了牌Q，这个操作就是PUSH，然后你又把牌Q从牌盒中拿出来，你可以返回到之前的牌J，这个操作就是POP，通常PUSH操作你只能按顺序一次次的放入一个个对象，这个对象也许是一张牌，但是也有可能是封装多个同级页面的容器，比如说你的Tab容器页面；这就是单页面最简单的跳转和返回路由操作，其他还有以下相关操作： reset（重置）： 在已经有牌J、Q、K的牌盒里面，把所有的牌全部一次性拿出，放入牌A，这个过程就是重置你的整个路由； popTo（返回指定页面）： 对已经有牌J、Q、K的牌盒里面对各牌进行按顺序下标0，1，2，其实就是数组结构，当前情况下你可以看到牌K，你的pop()返回至Q其实相当于popTo（1），你还可以使用popTo（0），这样你就等于一次性移开了最上面的牌Q、K，而你的牌盒中只剩下了J，这样相当于一次性按顺序返回多个页面； getCurrentRoutes（获取当前所有路由）： 对已经有牌J、Q、K的牌盒里面对各牌进行按顺序下标0，1，2，你可以获取到这个牌盒概念的路由数组，你可以对当前里面的牌进行指定操作。 延伸： 你的App即是你的牌盒，你只能对你牌盒中已经有的牌进行操作，当然你也可以新拿一张牌放入牌盒中进行操作，但是如果你的牌本身不在你的牌盒中，你是无法进行操作的，所以有时候如果这个牌都不在你的牌盒中，你使用通知-观察等这样的概念去操作一个不存在的页面对象是不会成功的。 Navigator使用和封装点击查看官方文档 0.44版本后Navigator已经从react-native库中移除，如需导入可按如下操作: 12345// install$npm install React-native-deprecated-custom-components --save// import APIimport CustomerComponents, &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos;; 实际项目中对于单页面应用，我们可以把Navigator封装成一个组件，把各页面当作Navigator的一个个场景转换，在页面中实现跳转，返回，动画等的各种操作时只需要调用相应方法即可。 123456789101112131415161718192021222324252627282930313233343536373839class APP extends Component &#123; constructor(props) &#123; super(props); this._renderScene = this._renderScene.bind(this); this.state = &#123;&#125;; &#125; /* eslint-disable */ _renderScene(route, navigator) &#123; let Component = route.component; return ( &lt;Component &#123;...route&#125; navigator=&#123;navigator&#125; passProps=&#123;route.passProps&#125; callback=&#123;route.callback&#125; /&gt; ); &#125; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &lt;Navigator ref="navigator" renderScene=&#123;this._renderScene&#125; configureScene=&#123;(route) =&gt; (&#123; ...route.sceneConfig || Navigator.SceneConfigs.HorizontalSwipeJump, gestures: route.gestures &#125;)&#125; initialRoute=&#123;&#123; component: Login &#125;&#125; /&gt; &lt;LoadingView isVisible=&#123;this.props.showLoading&#125; /&gt; &lt;/View&gt; ) &#125;&#125; 除了场景转换等操作，还可以在这个组件中集成控制App全局的一些操作，比如说，Loading的设置，网络状态检查等设置，在各页面就无须再单独设置。尽量在一个地方里面实现控制app的一些相近的默认操作 实际页面中跳转或其他操作： 123456789101112131415_jumpPage() &#123; const &#123; navigator &#125; = this.props; if (navigator) &#123; navigator.push(&#123; component: TabBarList, //next route sceneConfig: Navigator.SceneConfigs.FloatFromBottomAndroid, // animated config callback: () =&gt; &#123;&#125; //callback passProps: &#123; //transfer parameters tabs: 'home', activeTab: 'home', onPressHandler: this.props.goToPage &#125; &#125;); &#125; &#125; React Navigation理解和使用点击查看官方文档 react-native 0.44版本之前路由控制使用的Navigator虽然非常稳定，基本没出现过什么BUG，但是跳转效果一直被人诟病，跳转时候的动画和原生App的效果相比，非常明显差一等，在0.44版本后Facebook推荐使用react-navigation库来实现页面跳转，tab转换，侧边栏滑动等功能。 react-navigation主要包括导航，底部tab，顶部tab，侧滑等，功能很强大，而且体验接近原生。接下来会一一介绍： 导航 -&gt; StackNavigator 底部或者顶部tab -&gt; TabNavigator 关于侧滑DrawerNavigator的使用，笔者不在本文介绍，但可以看这篇附带Demo的推荐博客 ####StackNavigator StackNavigator在功能上就是相当于原来使用Navigator，但是他有着不一样的实现和非常好的跳转体验，使用上也非常简单，其实也就是三部曲： 路由配置（页面注册）： 12345const routeConfigs = &#123; Login: &#123; screen: Login &#125;, TabBar: &#123; screen: TabBarContainer &#125;, Feedback: &#123; screen: Feedback &#125;,&#125;; 默认场景配置： 123456789101112131415161718192021const stackNavigatorConfig = &#123; initialRouteName: 'Login', navigationOptions: &#123; headerBackTitle: null, headerTintColor: 'white', showIcon: true, swipeEnabled: false, animationEnabled: false, headerStyle: &#123; backgroundColor: '#f2f2f2' &#125; &#125;, mode: 'card', paths: 'rax/: Login', headerMode: 'float', transitionConfig: (() =&gt; (&#123; screenInterpolator: CardStackStyleInterpolator.forHorizontal // android's config about jump to next page &#125;)), onTransitionStart: () =&gt; &#123;&#125;, onTransitionEnd: () =&gt; &#123;&#125;&#125;; 容器生成与初始化: 12345678const Nav = StackNavigator(routeConfigs, stackNavigatorConfig);export default class QQDrawerHome extends Component &#123; render() &#123; return( &lt;Nav/&gt; ); &#125;&#125; 这样就简单完成了路由的配置，开发时只需要把新页面添加到注册对象routeConfigs中，StackNavigator会对里面的的注册页面和注册时使用的KEY值形成对应关系，当你在页面时跳转时，只需要这样： 1234567_jumpPage() &#123; const &#123; navigation &#125; = this.props; if (navigation) &#123; const &#123; navigation &#125; = this.props; navigation.navigate('TabBar'); &#125;&#125; 带参数跳转时： 12345678910_jumpPage() &#123; const &#123; navigation &#125; = this.props; if (navigation) &#123; const &#123; navigation &#125; = this.props; navigation.navigate('TabBar', &#123; visible: false, title: '首页' &#125;); &#125;&#125; 在下个页面就可以拿到参数并设置头部或其他参数： 1234567static navigationOptions = (&#123; navigation &#125;) =&gt; &#123; const &#123; state &#125; = navigation; const &#123; title &#125; = state.params; return &#123; title: title, &#125;; &#125;; 其他reset，setParams等操作将可以学着本文后面封装到组件中去使用，当然你也可以直接在页面跳转函数中重置路由，就像这样： 1234567const resetAction = NavigationActions.reset(&#123; index: 0, actions: [ NavigationActions.navigate(&#123; routeName: 'Login'&#125;) ]&#125;)this.props.navigation.dispatch(resetAction) ####TabNavigator0.44版本之前我们实现Tab页面通常都选择使用框架react-native-tab-navigator或者react-native-scrollable-tab-view，现在0.44版本后react-navigation库中推荐使用TabNavigator，同样的使用方式，类似StackNavigator三部曲： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const routeConfigs = &#123; Message:&#123; screen:QQMessage, navigationOptions: &#123; tabBarLabel: '消息', tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./notif-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt;), &#125; &#125;, Contact:&#123; screen:QQContact, navigationOptions: &#123; tabBarLabel: '联系人', tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./notif-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt;), &#125; &#125;,&#125;;const tabNavigatorConfig = &#123; tabBarComponent:TabBarBottom, tabBarPosition:'bottom', swipeEnabled:false, animationEnabled:false, lazy:true, initialRouteName:'Message', backBehavior:'none', tabBarOptions:&#123; activeTintColor:'rgb(78,187,251)', activeBackgroundColor:'white', inactiveTintColor:'rgb(127,131,146)', inactiveBackgroundColor:'white', labelStyle:&#123; fontSize:12 &#125; &#125; &#125; export default TabNavigator(routeConfigs, tabNavigatorConfig); 关于使用TabNavigator的一些注意点和当前问题： 如你甚至未使用StackNavigator，而想直接使用TabNavigator，还是用其他第三方框架吧，他和StackNavigator是配套使用的，你必须保证TabNavigator存在于StackNavigator中，TabNavigator才能良好工作。 当你当前页面使用了TabNavigator，那么TabNavigator所形成的容器组件应该是当前页面的顶层组件，否则报错，获取router为underfined。 关于嵌套使用TabNavigator，即在TabNavigator的一个screen中再次使用了TabNavigator形成页面，安卓平台下无法渲染子组件，页面空白，且内层Tab基本失效，或者你的内层Tab容器使用其他第三方框架如react-native-tab-view等类似框架，问题依然存在，关于此问题可关注公关BUG#1796。 ####StackNavigator路由的集中封装 此部分集成了一部分Redux知识，建议可以看一下redux官方文档了解一下redux。StackNavigator本身就集成了Redux来进行路由数据的管理，如你想要将你自己的redux管理集成到StackNavigator中，官方同样提供接口addNavigationHelpers，这里我们关注的是如何把reset，setParams等Navigator中的Action直接封装到组件中形成页面调用接口。 以下是笔者的封装组件，类似之前封装Navigator组件封装集中管理组件的思路代码，我们把StackNavigator同样封装为一个组件作为管理中心 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106......const AppNavigator = StackNavigator(RouteConfigs, stackNavigatorConfig);// eslint-disable-lineclass MainContainer extends Component &#123; constructor(props) &#123; super(props); this.resetRouteTo = this.resetRouteTo.bind(this); this.resetActiveRouteTo = this.resetActiveRouteTo.bind(this); this.backTo = this.backTo.bind(this); this.setParamsWrapper = this.setParamsWrapper.bind(this); this.state = &#123;&#125;; &#125; resetRouteTo(route, params) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; dispatch( NavigationActions.reset(&#123; index: 0, actions: [NavigationActions.navigate(&#123; routeName: route, params: params &#125;)], &#125;) ); &#125; &#125; resetActiveRouteTo(routeArray, activeIndex) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; const actionsArray = []; for (let i = 0; i &lt; routeArray.length; i++) &#123; actionsArray.push(NavigationActions.navigate(&#123; routeName: routeArray[i] &#125;)); &#125; const resetAction = NavigationActions.reset(&#123; index: activeIndex, actions: actionsArray, &#125;); dispatch(resetAction); &#125; &#125; backTo(key) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; dispatch( NavigationActions.reset(&#123; key: key &#125;) ); &#125; &#125; setParamsWrapper(params, key) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; const setParamsAction = NavigationActions.setParams(&#123; params: params, key: key, &#125;); dispatch(setParamsAction); &#125; &#125; render() &#123; const &#123; dispatch, navigationState, screenProps &#125; = this.props; return ( &lt;View style=&#123;&#123; flex: 1 &#125;&#125; onStartShouldSetResponder=&#123;() =&gt; dismissKeyboard()&#125; &gt; &lt;StatusBar barStyle="light-content" /&gt; &lt;AppNavigator navigation=&#123;addNavigationHelpers(&#123; dispatch: dispatch, state: navigationState, resetRouteTo: (route, params) =&gt; this.resetRouteTo(route, params), resetActiveRouteTo: (routeArray, activeIndex) =&gt; this.resetActiveRouteTo(routeArray, activeIndex), backTo: (key) =&gt; this.backTo(key), setParamsWrapper: (params, key) =&gt; this.setParamsWrapper(params, key) &#125;)&#125; screenProps=&#123;screenProps&#125; /&gt; &lt;Loading isVisible=&#123;true&#125; mode="alipay" /&gt; &lt;/View&gt; ); &#125;&#125;const mapStateToProps = (state) =&gt; &#123; const newNavigationState = state.navReducer; if (state.screenProps) &#123; newNavigationState.params = &#123; ...state.params, ...state.screenProps &#125;; &#125; return &#123; navigationState: newNavigationState, screenProps: state.screenProps &#125;;&#125;;export default connect(mapStateToProps)(MainContainer);...... 其中绑定navReducer文件的数据，可参考redux和react-navigation官网文档，此文不再列出 这样封装后，各页面使用reset，setParams等操作时，就可以像以前一样直接使用相关操作，如重置路由： 123456_jumpPage() &#123; const &#123; navigation &#125; = this.props; if (navigation) &#123; navigation.resetRouteTo('TabBar', &#123; title: '首页', selectedTab: 'home' &#125;); &#125;&#125; 写在最后笔者第一次写博客，如果有什么不足之处，或者上面的一些问题有什么不对的，欢迎大家批评与指正，一起学习和进步。 相关文章可参考： ReactNative导航新宠儿react-navigation React Native未来导航者：react-navigation 使用详解]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
</search>