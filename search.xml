<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序开发技术总结]]></title>
    <url>%2F2017%2F07%2F06%2F%E5%BE%AE%E4%BF%A1%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[微信小程序开发技术总结 小程序开发技术介绍 文件结构 WXML和WXSS简单介绍 app.json和page页面下的*.json简单配置 小程序开发技术局限 微信小程序原生架构局限 微信小程序的发布代码包限制 微信小程序页面层级限制 微信小程序关于网络请求的限制 小程序开发过程中填坑指南 小程序租金计算器开发总结 ##小程序开发技术介绍 ###文件结构 123456789101112+ images+ pages + 以*为名字的文件夹 + *.js + *.json + *.wxml + *.wxss+ util + *.js+ app.js+ app.json+ app.wxss 小程序包含一个描述整体的app和多个描述各自的page，pages文件夹下面每一个文件夹即是一个页面的逻辑和页面实现；一个小程序主体部分由三个文件组成，必须在项目根目录，如下： 文件 必填 作用 app.js 是 小程序逻辑 app.json 是 小程序公共设置 app.wxss 否 小程序公共样式表 一个小程序页面由4个文件组成，分别是： 文件类型 必填 作用 *.js 是 页面逻辑 *.wxml 是 页面结构 *.wxss 否 页面样式表 *.json 否 页面配置 注意：为了方便开发者减少配置项，规定描述页面的四个文件具有相同的路径与文件名 ###WXML和WXSS简单介绍 WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统、可以构建出页面结构; 数据绑定 12&lt;!--wxml--&gt;&lt;view&gt; &#123;&#123;message&#125;&#125; &lt;/view&gt; 123456//page.jspage(&#123; data: &#123; message: 'Hello world' &#125;&#125;) * 事件绑定 12&lt;!--wxml--&gt;&lt;view bindtap="add"&gt; &#123;&#123;count&#125;&#125; &lt;/view&gt; 1234567891011//page.jsPage(&#123; data: &#123; count: 1 &#125;, add: function(e) &#123; this.setData(&#123; count: this.data.count + 1 &#125;) &#125;&#125;) WXSS (WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式。就类似web应用的css层叠样式表 尺寸单位 微信小程序除了可以使用css的单位px和相对位置百分比的方式，还使用了一种新的尺寸单位rpx，rpx（responsive pixel）： 可以根据宽度进行自适应，规定屏幕宽为750rpx; 如在iPhone6上，屏幕宽度为375px，共有750个物理像素，则750rpx=375px=750px，1rpx=0.5px=1物理像素。 详细可参考blog：微信小程序新单位rpx与自适应布局 样式导入 1234 /** common.wxss **/.small-p &#123; padding:5px;&#125; 12345/** app.wxss **/@import "common.wxss";.middle-p &#123; padding:15px;&#125; 内联样式 style: 静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。 1&lt;view style="color:&#123;&#123;color&#125;&#125;;" /&gt; * class: 用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。 1&lt;view style="color:&#123;&#123;color&#125;&#125;;" /&gt; ###app.json和page页面下的*.json简单配置 app.json 小程序使用app.json文件对微信小程序进行全局配置，决定页面文件对路径、窗口表现、设置网络超时时间、设置多tab等 | 属性 | 类型 | 必填 | 描述 | | :—– | :—–: | :—–: | :—– | | pages | String Array | 是 | 设置页面路径 | | window | Object | 否 | 设置默认页面的窗口表现 | | tabBar | Object | 否 | 设置底部tab的表现 | | networkTimeout | Object | 否 | 设置网络超时间 | | debug | Object | 否 | 设置是否开启debug模式 | pages.json 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键。 | 属性 | 类型 | 默认值 | 描述 | | :—– | :—–: | :—–: | :—– | | navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如”#000000” | | navigationBarTextStyle | String | white | 导航栏标题颜色，仅支持 black/white | | navigationBarTitleText | String | 1 | 导航栏标题文字内容 | | backgroundColor | HexColor | #ffffff | 窗口的背景色 | | backgroundTextStyle | String | dark | 下拉背景字体、loading 图的样式，仅支持 dark/light | | enablePullDownRefresh | Boolean | false | 是否开启下拉刷新 | | disableScroll | Boolean | false | 设置为 true 则页面整体不能上下滚动；只在 page.json 中有效，无法在 app.json 中设置该项 | 备注： 详细的配置请参考官方API; ##小程序开发技术局限性和注意点 ###微信小程序原生架构局限微信小程序原生架构局限模块化，数据管理，复用性等皆较差，在此基础上直接开发，效率和代码规范性，模块化等问题突出，因而可以考虑集成一些开发的基础骨架和框架，类似webapp般的开发。现阶段Github上面已经有一部分优秀的骨架框架和集成redux管理开发数据等不错的框架，本次开发租金计算器，未集成任何开发工具和开发骨架，在开发流程上有些许不足和限制，接下来会考虑加入开发基础骨架和redux框架集成，让开发微信小程序流程接近web级开发流程。框架推荐：weapp-boilerplate;wxapp-redux-starter; ###微信小程序的发布代码包限制微信官方限制小程序的发布代码不能超过 1MB，因而在此处有两点要注意：一、集成开发框架时，编译输出要上传的代码到dist文件夹，且不可以超出1MB；二、际开发过程中，一般的小程序难免会有图片等富媒体文件，而这些富媒体文件会占用大量的存储空间；关于第二点，一般项目不会遇到，这里提供了一种结合七牛服务提出了解决方案，可解决类似问题作为参考：突破微信小程序存储限制的技巧与方法详解 ###微信小程序页面层级限制微信小程序官方限制页面使用类似router栈级结构层级不可以超过5层，因而页面间逻辑不可以过于复杂，在此基础上，开发者可以从页面逻辑设计、wx.redirectTo等API问题上尽量优化以求得规避该限制带来的最小影响。 ###微信小程序关于网络请求的限制微信小程序开发过程中未有appid时，网络请求未经过检验，基本不存在限制，只是简单的请求和响应，但是绑定appid和发布时，切记网络请求域名要在微信公众平台绑定，且域名使用https协议和后台需要 Nginx 配置 HTTPS 的加密标准为 TLS 1.2 及以上。 ##小程序开发过程中填坑指南 列表渲染问题 微信小程序渲染列表方式： 123&lt;view wx:for="&#123;&#123;array&#125;&#125;" wx:for-index="idx" wx:for-item="itemName"&gt; &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;&lt;/view&gt; 在列表界面和数据实现双向绑定时，切记绑定wx：key属性，否则会出现数据和界面无法对应问题，关于wx：key 属性和多层嵌套列表参考[列表渲染多层嵌套循环及wx:key的使用--微信小程序入门教程](http://lanchenglv.com/article/2016/1124/wxapp_list_foreach.html) 关于input的type属性 建议设置该属性，且设置后赋值一定要正确，特别是该页面下多个input，否则可能引起真机下该input无法聚焦输入 关于网络请求状态&gt;400处理 微信小程序网络请求对400以上的状态码会当做请求成功处理，也因此微信小程序对于客户端session会话验证方式采用了一套自己的方式，关于微信session会话参考官方API, 这里建议在请求封装函数里面做一个对status&gt;=400的特别处理以解决问题 小程序页面间数据传递和更新上一页面数据 小程序页面间数据传递使用的是类似网络GET请求般传递参数，非常不方便，这里建议重新封装一个自己的跳转工具类，参考小程序踩坑记《三》复杂数据的传递, 还有另外一种方法，在传递数据时，强转对象为字符串，再新页面使用JSON.parse()转回对象； 关于小程序事件冒泡 小程序点击事件有和web开发类似的冒泡机制，这里可以去看官方文档关于catchbind和bind的不同点, 以及关于事件参数target和currentTarget的区别，良好使用这些参数，可以更加灵活的使用小程序的事件冒泡机制。 关于小程序长按事件、双击事件等和单击事件的冲突 微信小程序事件触发顺序: 单击 touchstart → touchend → tap 双击 touchstart → touchend → tap → touchstart → touchend → tap 长按 touchstart → longtap → touchend → tap 为了解决这个冲突，这里提供良好的解决方案解决问题，可看代码： 12// wxml&lt;view bindtouchstart="bindTouchStart" bindtouchend="bindTouchEnd" bindtap="bindTap"&gt;蹂躏我&lt;/view&gt; 1234567891011121314// jsbindTouchStart: function(e) &#123; this.startTime = e.timeStamp;&#125;bindTouchEnd: function(e) &#123; this.endTime = e.timeStamp;&#125;bindTap: function(e) &#123; if(this.endTime - this.startTime &gt; 350) &#123; console.log("长按"); &#125; else &#123; console.log("点击") &#125;&#125; **更多问题请进入：** [微信小程序官网论坛](http://developers.weixin.qq.com) ##小程序租金计算器开发总结微信小程序-租金计算器版本v1.0.5已正式发布，基本的租金测算功能已实现，并能初步实现和web端系统类似的租金测算功能，不断的优化和更新后，可实现与web端类似租金测算功能。在实际应用场景，客户经理用于进行简单租金计算并向客户展示的情况下，可良好操作并应用。 当前版本： 线上版本v1.0.7: 代码通过审核并发布线上稳定版本，iOS与安卓端都能正常运行与计算； 体验版本v1.0.7: 代码提交后但未提交审核，发布体验版本，绑定体验的微信号用户可使用，用于小程序测试，开发者可实时提交更新该版本，可用于各体验者测试；绑定体验者请联系管理员dpcui@amarsoft.com 开发版本：开发者实时真机预览与测试版本，随时间过长可能失效 版本更新和新功能设计： 版本v2.0.0: 添加精简版计算模式和完整版计算模式，用于不同场景下的计算和使用； 版本v3.0.0: 功能待定]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native可伸缩列表封装与快速实现方案]]></title>
    <url>%2F2017%2F07%2F04%2FReact%20Native%2FReact%20Native%E5%8F%AF%E4%BC%B8%E5%B1%95%E5%88%97%E8%A1%A8%E5%B0%81%E8%A3%85%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[React Native可伸缩列表封装与快速实现方案 类似QQ好友列表的可伸缩分组列表，相信对于一部分的开发者来说还是有需要用到的，笔者将会结合自己的开发理解和已发布在github和npm上的实例，结合讲解如何使用React Native快速封装此类组件。你也可以查看笔者已经封装并发布的组件react-native-expandable-section-list查看效果，当然在你的项目中，你也可以直接使用该组件，如发现任何bug请及时提出issue给我，我会认真处理，如果你觉得笔者做的还不错，请给我一个star哦！ ##封装思路解析原生ios开发阶段时，UITableView功能强大，实现类似QQ列表这样的功能，你只需要在UITableView的delegate方法中作相关控制即可实现，但是最开始转到react native的时候，笔者由于当时刚参加工作，没什么思路，后经过一些尝试和封装，笔者有了现在的实现方法 思路一： 通过View的onLayout回调记录分组布局大小，控制打开组高度和关闭组高度实现类似开关分组效果（这个思路和代码是一个同事的方法，代码稍微有点绕，但是可以控制打开关闭的动画，笔者暂时放弃了，但是笔者下一篇文章会来讲解这个方法的思路和实现） 思路二： 控制数据，改变开关分组的标记值，并结合react native的state渲染实现类似开关分组效果（这是笔者当前用在实际项目中的一个组件，下面会具体介绍如何实现它的代码和思路） ##代码解析首先渲染一个全屏的ListView，ListView中的row当作分组，row渲染成下列组件： 分组渲染： 123456789101112131415161718192021222324252627_renderRow = (rowData, sectionId, rowId) =&gt; &#123; // eslint-disable-line const &#123; renderRow, renderSectionHeaderX, renderSectionFooterX, headerKey, memberKey &#125; = this.props; let memberArr = rowData[memberKey]; if (!this.state.memberOpened.get(rowId) || !memberArr) &#123; memberArr = []; &#125; return ( &lt;View&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; this._onPress(rowId)&#125;&gt; &#123; renderSectionHeaderX ? renderSectionHeaderX(rowData[headerKey], rowId) : null&#125; &lt;/TouchableOpacity&gt; &lt;ScrollView scrollEnabled=&#123;false&#125;&gt; &#123; memberArr.map((rowItem, index) =&gt; &#123; return ( &lt;View key=&#123;index&#125;&gt; &#123;renderRow ? renderRow(rowItem, index, sectionId) : null&#125; &lt;/View&gt; ); &#125;) &#125; &#123; memberArr.length &gt; 0 &amp;&amp; renderSectionFooterX ? renderSectionFooterX(rowData, sectionId) : null &#125; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125; 说明：如代码，每个Row中都由renderSectionHeaderX、renderRow、renderSectionFooterX组成，renderSectionHeaderX通过Touchable组件的点击事件，可以控制下面的ScrollView包着的一个个组成员renderRow，及sectionFooter，每次渲染这样一个分组的时候通过当前组的开关状态this.state.memberOpened来获得当前memberArr数组是空数组或是你的传入数据rowData[memberKey],当然也可以控制你的关闭状态不一定是空数组，这里的开关状态寄存器是一个Map对象，或者你也可以自己构造合适的键值对对象 开关对象构造： 123456789101112131415constructor(props) &#123; super(props); this.ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;); let map = new Map(); if (props.dataSource &amp;&amp; props.isOpen) &#123; props.dataSource.map((item, i) =&gt; map.set(i.toString(), true)) &#125; if (props.openOptions) &#123; props.openOptions.map((item) =&gt; map.set(item.toString(), true)) &#125; this.state = &#123; memberOpened: map &#125; &#125; 说明：构造状态寄存器，通过属性设置默认的分组开关状态，isOpen是bool值，记录是否全部打开分组, openOptions是一个数组，里面记录你选择打开哪些分组，如打开0, 2分组，即为[0,2] 点击开关方法： 12345678910111213_onPress = (i) =&gt; &#123; this.setState((state) =&gt; &#123; const memberOpened = new Map(state.memberOpened); memberOpened.set(i, !memberOpened.get(i)); // toggle return &#123; memberOpened &#125;; &#125;); if (this.props.headerOnPress) &#123; this.prop.headerOnPress(i, this.state.memberOpened.get(i) || false); &#125; LayoutAnimation.easeInEaseOut(); &#125;; 说明：每次点击组头，执行该方法，改变当前组在状态寄存器中设置的状态，最开始笔者甚至把这状态寄存设置成为每个分组数据的某个特定属性，后来发现Map拿来这里当作一种寄存器用真的很完美。 数据源 123456789101112131415const MockData = [ ... &#123; header: &apos;sectionHeader&apos;, member: [ ... &#123; title: &apos;memberTitle&apos;, content: &apos;content&apos;, &#125;, ... ] &#125;, ... ] 特定组件是拿来做特定用途的，所以笔者做的react-native-expandable-section-list只适用于笔者说明的情况，当然，也对数据源做一定的限制，从而快速封装出来QQ列表的可伸缩分组效果。 ##FlatList扩展封装react native在版本0.43后提出使用FlatList，笔者在使用FlatList的时候，通过同样的思路也对FlatList做了类似的扩展，组件可见react-native-expandable-section-flatlist，0.43版本后的FlatList确实是对列表组件性能做了极大的提升，数据源data属性，加上扩展数据属性extraData的使用让每次的state组件渲染不会再是渲染当前列表，而是直接定位到你作出改变的分组从而改变分组的开关状态。keyExtractor属性也更加利于定位每一个分组的位置和设定，笔者在数据测试时只做了100个分组的测试，FlatList的性能原理是只会显示你看到的这部分分组，做的还是相当好的，暂未发现性能影响。笔者尽量减少对原组件FlatList的属性影响，其他类似上拉刷新，下拉加载等属性也全部兼容，接下来直接展示精简后的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class ExpanableList extends Component &#123; constructor(props) &#123; super(props); let map = new Map(); if (props.dataSource &amp;&amp; props.isOpen) &#123; props.dataSource.map((item, i) =&gt; map.set(i, true)) &#125; if (props.openOptions) &#123; props.openOptions.map((item) =&gt; map.set(item, true)) &#125; this.state = &#123; memberOpened: map &#125; &#125; static propTypes = &#123; dataSource: PropTypes.array.isRequired, headerKey: PropTypes.string, memberKey: PropTypes.string, renderRow: PropTypes.func, renderSectionHeaderX: PropTypes.func, renderSectionFooterX: PropTypes.func, headerOnPress: PropTypes.func, isOpen: PropTypes.bool, openOptions: PropTypes.array, &#125;; static defaultProps = &#123; headerKey: 'header', memberKey: 'member', isOpen: false, &#125;; _keyExtractor = (item, index) =&gt; index; _onPress = (i) =&gt; &#123; this.setState((state) =&gt; &#123; const memberOpened = new Map(state.memberOpened); memberOpened.set(i, !memberOpened.get(i)); // toggle return &#123; memberOpened &#125;; &#125;); if (this.props.headerOnPress) &#123; this.prop.headerOnPress(i, this.state.memberOpened.get(i) || false); &#125; LayoutAnimation.easeInEaseOut(); &#125;; _renderItem = (&#123; item, index &#125;) =&gt; &#123; // eslint-disable-line const &#123; renderRow, renderSectionHeaderX, renderSectionFooterX, headerKey, memberKey &#125; = this.props; const sectionId = index; let memberArr = item[memberKey]; if (!this.state.memberOpened.get(sectionId) || !memberArr) &#123; memberArr = []; &#125; return ( &lt;View&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; this._onPress(sectionId)&#125;&gt; &#123; renderSectionHeaderX ? renderSectionHeaderX(item[headerKey], sectionId) : null&#125; &lt;/TouchableOpacity&gt; &lt;ScrollView scrollEnabled=&#123;false&#125;&gt; &#123; memberArr.map((rowItem, rowId) =&gt; &#123; return ( &lt;View key=&#123;rowId&#125;&gt; &#123;renderRow ? renderRow(rowItem, rowId, index) : null&#125; &lt;/View&gt; ); &#125;) &#125; &#123; memberArr.length &gt; 0 &amp;&amp; renderSectionFooterX ? renderSectionFooterX(item, sectionId) : null &#125; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125;; render() &#123; const &#123; dataSource &#125; = this.props; return ( &lt;FlatList &#123;...this.props&#125; data=&#123;dataSource&#125; extraData=&#123;this.state&#125; keyExtractor=&#123;this._keyExtractor&#125; renderItem=&#123;this._renderItem&#125; /&gt; ); &#125;&#125; ##写在最后react-native-expandable-section-list和react-native-expandable-section-flatlist封装的相对简单，但是还是很实用的，笔者的一点小经验分享希望能对你有所帮助。 写总结和分享文章确实是一件快乐的事情，笔者的第一篇文章React Native路由理解和react-navigation库封装学习受到了一些人的肯定，真的很开心，谢谢各位，一起进步！！]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native路由理解和react-navigation库封装学习]]></title>
    <url>%2F2017%2F06%2F20%2FReact%20Native%2FReact%20Native%E8%B7%AF%E7%94%B1%E7%90%86%E8%A7%A3%E5%92%8Creact-navigation%E5%BA%93%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[React Native路由理解和react-navigation库封装学习从0.44版本开始Facebook放弃了原来的Navigator接口控制RN应用的路由跳转，并推荐使用react-navigation库实现应用的导航和跳转等功能。本文不止会介绍react-navigation的学习和使用，并同时也会介绍曾经的Navigator接口使用并介绍它们如何在应用中实现路由跳转的集中管理。笔者不会过多的介绍Navigator和react-navigation各个属性和方法的使用，笔者旨在学习和理解在react native中的栈结构路由的使用。 栈概念理解对于手机应用中单页面应用（SPA）的路由，你可以这样理解： 应用（APP）== 整套扑克牌（包括牌盒） 栈容器（Navigator或React-Navigation中的 StackNavigator）== 牌盒 页面（路由） == 牌 现在我们往空牌盒里面放入牌J，这是你的初始化页面，你可以再放入一张牌Q，盖住了牌J，在你的应用中你看到的页面就变成了牌Q，这个操作就是PUSH，然后你又把牌Q从牌盒中拿出来，你可以返回到之前的牌J，这个操作就是POP，通常PUSH操作你只能按顺序一次次的放入一个个对象，这个对象也许是一张牌，但是也有可能是封装多个同级页面的容器，比如说你的Tab容器页面；这就是单页面最简单的跳转和返回路由操作，其他还有以下相关操作： reset（重置）： 在已经有牌J、Q、K的牌盒里面，把所有的牌全部一次性拿出，放入牌A，这个过程就是重置你的整个路由； popTo（返回指定页面）： 对已经有牌J、Q、K的牌盒里面对各牌进行按顺序下标0，1，2，其实就是数组结构，当前情况下你可以看到牌K，你的pop()返回至Q其实相当于popTo（1），你还可以使用popTo（0），这样你就等于一次性移开了最上面的牌Q、K，而你的牌盒中只剩下了J，这样相当于一次性按顺序返回多个页面； getCurrentRoutes（获取当前所有路由）： 对已经有牌J、Q、K的牌盒里面对各牌进行按顺序下标0，1，2，你可以获取到这个牌盒概念的路由数组，你可以对当前里面的牌进行指定操作。 延伸： 你的App即是你的牌盒，你只能对你牌盒中已经有的牌进行操作，当然你也可以新拿一张牌放入牌盒中进行操作，但是如果你的牌本身不在你的牌盒中，你是无法进行操作的，所以有时候如果这个牌都不在你的牌盒中，你使用通知-观察等这样的概念去操作一个不存在的页面对象是不会成功的。 Navigator使用和封装点击查看官方文档 0.44版本后Navigator已经从react-native库中移除，如需导入可按如下操作: 12345// install$npm install React-native-deprecated-custom-components --save// import APIimport CustomerComponents, &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos;; 实际项目中对于单页面应用，我们可以把Navigator封装成一个组件，把各页面当作Navigator的一个个场景转换，在页面中实现跳转，返回，动画等的各种操作时只需要调用相应方法即可。 123456789101112131415161718192021222324252627282930313233343536373839class APP extends Component &#123; constructor(props) &#123; super(props); this._renderScene = this._renderScene.bind(this); this.state = &#123;&#125;; &#125; /* eslint-disable */ _renderScene(route, navigator) &#123; let Component = route.component; return ( &lt;Component &#123;...route&#125; navigator=&#123;navigator&#125; passProps=&#123;route.passProps&#125; callback=&#123;route.callback&#125; /&gt; ); &#125; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &lt;Navigator ref="navigator" renderScene=&#123;this._renderScene&#125; configureScene=&#123;(route) =&gt; (&#123; ...route.sceneConfig || Navigator.SceneConfigs.HorizontalSwipeJump, gestures: route.gestures &#125;)&#125; initialRoute=&#123;&#123; component: Login &#125;&#125; /&gt; &lt;LoadingView isVisible=&#123;this.props.showLoading&#125; /&gt; &lt;/View&gt; ) &#125;&#125; 除了场景转换等操作，还可以在这个组件中集成控制App全局的一些操作，比如说，Loading的设置，网络状态检查等设置，在各页面就无须再单独设置。尽量在一个地方里面实现控制app的一些相近的默认操作 实际页面中跳转或其他操作： 123456789101112131415_jumpPage() &#123; const &#123; navigator &#125; = this.props; if (navigator) &#123; navigator.push(&#123; component: TabBarList, //next route sceneConfig: Navigator.SceneConfigs.FloatFromBottomAndroid, // animated config callback: () =&gt; &#123;&#125; //callback passProps: &#123; //transfer parameters tabs: 'home', activeTab: 'home', onPressHandler: this.props.goToPage &#125; &#125;); &#125; &#125; React Navigation理解和使用点击查看官方文档 react-native 0.44版本之前路由控制使用的Navigator虽然非常稳定，基本没出现过什么BUG，但是跳转效果一直被人诟病，跳转时候的动画和原生App的效果相比，非常明显差一等，在0.44版本后Facebook推荐使用react-navigation库来实现页面跳转，tab转换，侧边栏滑动等功能。 react-navigation主要包括导航，底部tab，顶部tab，侧滑等，功能很强大，而且体验接近原生。接下来会一一介绍： 导航 -&gt; StackNavigator 底部或者顶部tab -&gt; TabNavigator 关于侧滑DrawerNavigator的使用，笔者不在本文介绍，但可以看这篇附带Demo的推荐博客 ####StackNavigator StackNavigator在功能上就是相当于原来使用Navigator，但是他有着不一样的实现和非常好的跳转体验，使用上也非常简单，其实也就是三部曲： 路由配置（页面注册）： 12345const routeConfigs = &#123; Login: &#123; screen: Login &#125;, TabBar: &#123; screen: TabBarContainer &#125;, Feedback: &#123; screen: Feedback &#125;,&#125;; 默认场景配置： 123456789101112131415161718192021const stackNavigatorConfig = &#123; initialRouteName: 'Login', navigationOptions: &#123; headerBackTitle: null, headerTintColor: 'white', showIcon: true, swipeEnabled: false, animationEnabled: false, headerStyle: &#123; backgroundColor: '#f2f2f2' &#125; &#125;, mode: 'card', paths: 'rax/: Login', headerMode: 'float', transitionConfig: (() =&gt; (&#123; screenInterpolator: CardStackStyleInterpolator.forHorizontal // android's config about jump to next page &#125;)), onTransitionStart: () =&gt; &#123;&#125;, onTransitionEnd: () =&gt; &#123;&#125;&#125;; 容器生成与初始化: 12345678const Nav = StackNavigator(routeConfigs, stackNavigatorConfig);export default class QQDrawerHome extends Component &#123; render() &#123; return( &lt;Nav/&gt; ); &#125;&#125; 这样就简单完成了路由的配置，开发时只需要把新页面添加到注册对象routeConfigs中，StackNavigator会对里面的的注册页面和注册时使用的KEY值形成对应关系，当你在页面时跳转时，只需要这样： 1234567_jumpPage() &#123; const &#123; navigation &#125; = this.props; if (navigation) &#123; const &#123; navigation &#125; = this.props; navigation.navigate('TabBar'); &#125;&#125; 带参数跳转时： 12345678910_jumpPage() &#123; const &#123; navigation &#125; = this.props; if (navigation) &#123; const &#123; navigation &#125; = this.props; navigation.navigate('TabBar', &#123; visible: false, title: '首页' &#125;); &#125;&#125; 在下个页面就可以拿到参数并设置头部或其他参数： 1234567static navigationOptions = (&#123; navigation &#125;) =&gt; &#123; const &#123; state &#125; = navigation; const &#123; title &#125; = state.params; return &#123; title: title, &#125;; &#125;; 其他reset，setParams等操作将可以学着本文后面封装到组件中去使用，当然你也可以直接在页面跳转函数中重置路由，就像这样： 1234567const resetAction = NavigationActions.reset(&#123; index: 0, actions: [ NavigationActions.navigate(&#123; routeName: 'Login'&#125;) ]&#125;)this.props.navigation.dispatch(resetAction) ####TabNavigator0.44版本之前我们实现Tab页面通常都选择使用框架react-native-tab-navigator或者react-native-scrollable-tab-view，现在0.44版本后react-navigation库中推荐使用TabNavigator，同样的使用方式，类似StackNavigator三部曲： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const routeConfigs = &#123; Message:&#123; screen:QQMessage, navigationOptions: &#123; tabBarLabel: '消息', tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./notif-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt;), &#125; &#125;, Contact:&#123; screen:QQContact, navigationOptions: &#123; tabBarLabel: '联系人', tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./notif-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt;), &#125; &#125;,&#125;;const tabNavigatorConfig = &#123; tabBarComponent:TabBarBottom, tabBarPosition:'bottom', swipeEnabled:false, animationEnabled:false, lazy:true, initialRouteName:'Message', backBehavior:'none', tabBarOptions:&#123; activeTintColor:'rgb(78,187,251)', activeBackgroundColor:'white', inactiveTintColor:'rgb(127,131,146)', inactiveBackgroundColor:'white', labelStyle:&#123; fontSize:12 &#125; &#125; &#125; export default TabNavigator(routeConfigs, tabNavigatorConfig); 关于使用TabNavigator的一些注意点和当前问题： 如你甚至未使用StackNavigator，而想直接使用TabNavigator，还是用其他第三方框架吧，他和StackNavigator是配套使用的，你必须保证TabNavigator存在于StackNavigator中，TabNavigator才能良好工作。 当你当前页面使用了TabNavigator，那么TabNavigator所形成的容器组件应该是当前页面的顶层组件，否则报错，获取router为underfined。 关于嵌套使用TabNavigator，即在TabNavigator的一个screen中再次使用了TabNavigator形成页面，安卓平台下无法渲染子组件，页面空白，且内层Tab基本失效，或者你的内层Tab容器使用其他第三方框架如react-native-tab-view等类似框架，问题依然存在，关于此问题可关注公关BUG#1796。 ####StackNavigator路由的集中封装 此部分集成了一部分Redux知识，建议可以看一下redux官方文档了解一下redux。StackNavigator本身就集成了Redux来进行路由数据的管理，如你想要将你自己的redux管理集成到StackNavigator中，官方同样提供接口addNavigationHelpers，这里我们关注的是如何把reset，setParams等Navigator中的Action直接封装到组件中形成页面调用接口。 以下是笔者的封装组件，类似之前封装Navigator组件封装集中管理组件的思路代码，我们把StackNavigator同样封装为一个组件作为管理中心 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106......const AppNavigator = StackNavigator(RouteConfigs, stackNavigatorConfig);// eslint-disable-lineclass MainContainer extends Component &#123; constructor(props) &#123; super(props); this.resetRouteTo = this.resetRouteTo.bind(this); this.resetActiveRouteTo = this.resetActiveRouteTo.bind(this); this.backTo = this.backTo.bind(this); this.setParamsWrapper = this.setParamsWrapper.bind(this); this.state = &#123;&#125;; &#125; resetRouteTo(route, params) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; dispatch( NavigationActions.reset(&#123; index: 0, actions: [NavigationActions.navigate(&#123; routeName: route, params: params &#125;)], &#125;) ); &#125; &#125; resetActiveRouteTo(routeArray, activeIndex) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; const actionsArray = []; for (let i = 0; i &lt; routeArray.length; i++) &#123; actionsArray.push(NavigationActions.navigate(&#123; routeName: routeArray[i] &#125;)); &#125; const resetAction = NavigationActions.reset(&#123; index: activeIndex, actions: actionsArray, &#125;); dispatch(resetAction); &#125; &#125; backTo(key) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; dispatch( NavigationActions.reset(&#123; key: key &#125;) ); &#125; &#125; setParamsWrapper(params, key) &#123; const &#123; dispatch &#125; = this.props; if (dispatch) &#123; const setParamsAction = NavigationActions.setParams(&#123; params: params, key: key, &#125;); dispatch(setParamsAction); &#125; &#125; render() &#123; const &#123; dispatch, navigationState, screenProps &#125; = this.props; return ( &lt;View style=&#123;&#123; flex: 1 &#125;&#125; onStartShouldSetResponder=&#123;() =&gt; dismissKeyboard()&#125; &gt; &lt;StatusBar barStyle="light-content" /&gt; &lt;AppNavigator navigation=&#123;addNavigationHelpers(&#123; dispatch: dispatch, state: navigationState, resetRouteTo: (route, params) =&gt; this.resetRouteTo(route, params), resetActiveRouteTo: (routeArray, activeIndex) =&gt; this.resetActiveRouteTo(routeArray, activeIndex), backTo: (key) =&gt; this.backTo(key), setParamsWrapper: (params, key) =&gt; this.setParamsWrapper(params, key) &#125;)&#125; screenProps=&#123;screenProps&#125; /&gt; &lt;Loading isVisible=&#123;true&#125; mode="alipay" /&gt; &lt;/View&gt; ); &#125;&#125;const mapStateToProps = (state) =&gt; &#123; const newNavigationState = state.navReducer; if (state.screenProps) &#123; newNavigationState.params = &#123; ...state.params, ...state.screenProps &#125;; &#125; return &#123; navigationState: newNavigationState, screenProps: state.screenProps &#125;;&#125;;export default connect(mapStateToProps)(MainContainer);...... 其中绑定navReducer文件的数据，可参考redux和react-navigation官网文档，此文不再列出 这样封装后，各页面使用reset，setParams等操作时，就可以像以前一样直接使用相关操作，如重置路由： 123456_jumpPage() &#123; const &#123; navigation &#125; = this.props; if (navigation) &#123; navigation.resetRouteTo('TabBar', &#123; title: '首页', selectedTab: 'home' &#125;); &#125;&#125; 写在最后笔者第一次写博客，如果有什么不足之处，或者上面的一些问题有什么不对的，欢迎大家批评与指正，一起学习和进步。 相关文章可参考： ReactNative导航新宠儿react-navigation React Native未来导航者：react-navigation 使用详解]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
</search>